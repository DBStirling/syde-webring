name: Issue → PR (Add Node)

on:
  issues:
    types: [opened, edited, labeled]

permissions:
  contents: write
  pull-requests: write
  issues: read

jobs:
  make-pr:
    if: >
      github.event_name == 'issues' &&
      (
        (github.event.action == 'opened' && contains(join(github.event.issue.labels.*.name, ','), 'new-node')) ||
        (github.event.action == 'labeled' && github.event.label.name == 'new-node') ||
        (github.event.action == 'edited' && contains(join(github.event.issue.labels.*.name, ','), 'new-node'))
      )

    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Convert Issue → PR
        uses: actions/github-script@v7
        with:
        script: |
          const fs = require('fs');
          const path = require('path');

          const DATA_PATH = 'public/data.json';
          const BASE_BRANCH = 'main';

          const body = context.payload.issue.body || '';

          // Helper to escape any regex metacharacters in a string
          const escapeRegex = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

          // Extracts text after "### label" up to next "###" or end of file
          const grab = (label) => {
            const escapedLabel = escapeRegex(label);
            const re = new RegExp(`###\\s*${escapedLabel}\\s*\\n+([\\s\\S]*?)(?=\\n###|$)`, 'i');
            const match = body.match(re);
            return match ? match[1].trim() : '';
          };

          const fullName = grab('Full name');
          const yearStr  = grab('Year (YYYY)');
          const website  = grab('Website URL');
          const skill1   = grab('Primary skill');
          const skill2   = grab('Secondary skill');
          const skill3   = grab('Tertiary skill');
          const bio      = grab('Bio (optional)');

          // Validate inputs
          const errors = [];

          if (!fullName || fullName.length < 2 || fullName.length > 80) errors.push('Full name must be 2-80 chars.');
          const year = parseInt(yearStr, 10);
          if (!Number.isInteger(year) || year < 2000 || year > 2050) errors.push('Year must be a 4-digit year between 2000–2050.');

          if (!/^https?:\/\//i.test(website)) errors.push('Website must start with http:// or https://');

          const allowedSkills = [
            'UX/UI','UXR','Graphic','Brand',
            'Frontend','Backend','Full Stack','AI/ML','Quant','QA','Game Dev','SRE',
            'Product','Project','Program',
            'CAD/Simulation','Manufacturing','Materials','Automotive','Aero',
            'Embedded','Signals','Sensors','Robotics','Power Systems','Communications',
            'Data','Business','VC','IDK Yet!','Other'
          ];

          const skills = [skill1, skill2, skill3];
          if (skills.some(s => !allowedSkills.includes(s))) {
            errors.push('Skills must be chosen from the dropdown options.');
          }
          if (new Set(skills).size !== 3) {
            errors.push('Skills must be unique.');
          }

          if (errors.length) {
            core.setFailed('Validation failed:\n- ' + errors.join('\n- '));
            return;
          }

          // Load and parse existing data
          const dataPath = path.join(process.cwd(), DATA_PATH);
          if (!fs.existsSync(dataPath)) {
            core.setFailed(`Data file not found at ${DATA_PATH}`);
            return;
          }
          const json = JSON.parse(fs.readFileSync(dataPath, 'utf8'));

          const norm = s => (s || '').trim().toLowerCase().replace(/\/$/, '');
          const nameNorm = norm(fullName);
          const siteNorm = norm(website);

          const dup = (json.nodes || []).some(n =>
            norm(n.fullName) === nameNorm || norm(n.website) === siteNorm
          );
          if (dup) {
            core.setFailed('Duplicate detected: fullName or website already exists.');
            return;
          }

          const nextId = (json.nodes || []).length
            ? Math.max(...json.nodes.map(n => Number(n.id) || 0)) + 1
            : 1;

          const newNode = {
            id: nextId,
            fullName,
            year,
            skills: { skill1, skill2, skill3 },
            website,
            bio: bio || ''
          };

          json.nodes.push(newNode);
          json.nodes.sort((a, b) => a.fullName.localeCompare(b.fullName));
          const updated = JSON.stringify(json, null, 2) + '\n';

          const slug = fullName.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
          const branch = `add/${slug}-${Date.now()}`;

          const { data: base } = await github.rest.repos.getBranch({
            owner: context.repo.owner,
            repo: context.repo.repo,
            branch: BASE_BRANCH
          });

          await github.rest.git.createRef({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: `refs/heads/${branch}`,
            sha: base.commit.sha
          });

          const { data: fileData } = await github.rest.repos.getContent({
            owner: context.repo.owner,
            repo: context.repo.repo,
            path: DATA_PATH,
            ref: BASE_BRANCH
          });

          await github.rest.repos.createOrUpdateFileContents({
            owner: context.repo.owner,
            repo: context.repo.repo,
            path: DATA_PATH,
            message: `feat: add ${fullName} to webring`,
            content: Buffer.from(updated, 'utf8').toString('base64'),
            branch,
            sha: Array.isArray(fileData) ? undefined : fileData.sha
          });

          const pr = await github.rest.pulls.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            head: branch,
            base: BASE_BRANCH,
            title: `Add ${fullName} (${year})`,
            body: [
              'Auto-generated from Issue Form.',
              '',
              'Proposed node:',
              '```json',
              JSON.stringify(newNode, null, 2),
              '```'
            ].join('\n')
          });

          await github.rest.issues.createComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number,
            body: `Thanks! Opened PR #${pr.data.number} for review.`
          });

